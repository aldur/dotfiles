-- Original credits: https://github.com/VFS/.hammerspoon/blob/master/tools/clipboard.lua
-- luacheck: ignore module

local pasteboard_name='com.aldur.clipboard'
local archive_name='com.aldur.clipboard.archive'
local logger = hs.logger.new('clipboard')

module = {
    frequency=1.0,  -- Clipboar polling frequency.
    chooser_max_size=1000,  -- Number of elements to store in the chooser.
    element_max_length=1000,  -- Maximum length of elements to store.
    archive_max_size=10000,  -- Store additional n items in the 'archive'

    trim=true,  -- Strip leading/trailing whitespace

    consider_ignore=true,  -- Respect the `ignore` settings
    ignore = {
        ["de.petermaurer.TransientPasteboardType"] = true, -- Transient : Textpander, TextExpander, Butler
        ["com.typeit4me.clipping"]                 = true, -- Transient : TypeIt4Me
        ["Pasteboard generator type"]              = true, -- Transient : Typinator
        ["com.agilebits.onepassword"]              = true, -- Confidential : 1Password
        ["org.nspasteboard.TransientType"]         = true, -- Universal, Transient
        ["org.nspasteboard.ConcealedType"]         = true, -- Universal, Concealed
        ["org.nspasteboard.AutoGeneratedType"]     = true, -- Universal, Automatic
    },

    -- You don't need to edit anything below this line.
    last_change=hs.pasteboard.changeCount(),
    last_focused_window=nil,
    clipboard_history=hs.settings.get(pasteboard_name) or {},
    archive=hs.settings.get(archive_name) or {},
}

-- Internal method: Verify whether the pasteboard contents matches one of the identifiers that need to be ignored.
-- Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua
local function shouldBeStored()
    if not module.consider_ignore then return true end
    for _,v in ipairs(hs.pasteboard.pasteboardTypes()) do
        if module.ignore[v] then return false end
    end
    for _, v in ipairs(hs.pasteboard.contentTypes()) do
        if module.ignore[v] then return false end
    end
    return true
end

-- Clears the clipboard and history
local function clearAll()
    module.clipboard_history = {}
    hs.settings.set(pasteboard_name, module.clipboard_history)
    hs.pasteboard.clearContents()
    module.last_change = hs.pasteboard.changeCount()
    module.chooser:choices(module.clipboard_history)
end

-- Archives/clears the clipboard and history
local function archiveAll()
    while (#module.clipboard_history > 0) do
        table.insert(module.archive, 1, table.remove(module.clipboard_history))
    end

    while (#module.archive >= module.archive_max_size) do
        table.remove(module.archive)
    end

    hs.settings.set(archive_name, module.archive)
    hs.settings.set(pasteboard_name, module.clipboard_history)

    hs.pasteboard.clearContents()
    module.last_change = hs.pasteboard.changeCount()
    module.chooser:choices(module.clipboard_history)
end

-- Clears the last added to the history
local function clearLastItem()
    table.remove(module.clipboard_history, #module.clipboard_history)
    hs.settings.set(pasteboard_name, module.clipboard_history)
    module.last_change = hs.pasteboard.changeCount()
    module.chooser:choices(module.clipboard_history)
end

-- Add `item`
local function toClipboard(item)
    -- Look for a copy of this element in the clipboard, and remove it if it's there.
    for i, v in pairs(module.clipboard_history) do
        if v.text == item then
            table.remove(module.clipboard_history, i)
            break
        end
    end

    -- Store the new element.
    table.insert(module.clipboard_history, 1, {text=item, date=os.date()})

    -- Make sure that the clipboard size respects the requirements.
    while (#module.clipboard_history >= module.chooser_max_size) do
        table.insert(module.archive, 1, table.remove(module.clipboard_history))
    end

    -- Make sure that the archive size respects the requirements.
    while (#module.archive >= module.archive_max_size) do
        table.remove(module.archive)
    end

    -- Store the updated clipboard/archive.
    hs.settings.set(pasteboard_name, module.clipboard_history)
    hs.settings.set(archive_name, module.archive)
end

module.chooser = hs.chooser.new(function(row_info)
    if row_info then hs.pasteboard.setContents(row_info['text']) end
    if module.last_focused_window then module.last_focused_window:focus() end
end)
module.chooser:rows(9)  -- Show 9 rows of elements in the chooser.
module.chooser:choices(module.clipboard_history)

local function storeCopy()
    local now = hs.pasteboard.changeCount()
    if hs.pasteboard.changeCount() == module.last_change then return end
    assert(now > module.last_change)
    module.last_change = now

    if not shouldBeStored() then return end
    local current_clipboard = hs.pasteboard.getContents()

    if not current_clipboard then
        logger.v('Clipboard is empty. Clearing last item...')
        clearLastItem()
    elseif #current_clipboard > module.element_max_length then
        logger.v('Skipping entry too long...')
        return
    else
        if module.trim then
            -- Strip leading/trailing whitespace
            current_clipboard = current_clipboard:gsub("^%s*(.-)%s*$", "%1")
        end
        if not current_clipboard or current_clipboard == '' then return end

        toClipboard(current_clipboard)
    end
end

module.timer = hs.timer.new(module.frequency, storeCopy):start()

function module.toggle()
    local chooser = module.chooser
    if chooser:isVisible() then
        chooser:hide()
        if module.last_focused_window then module.last_focused_window:focus() end
    else
        module.last_focused_window = hs.window.focusedWindow()
        module.chooser:choices(module.clipboard_history)
        chooser:show()
    end
end

hs.urlevent.bind('clipboard', function(_, params)
    if params.clear_all then
        logger.i('Clearing the clipboard.')
        clearAll()
    elseif params.archive_all then
        logger.i('Archiving the clipboard.')
        archiveAll()
    else
        assert(params.clipboard)
        logger.i('Storing the clipboard.')

        local f = io.open(params.clipboard, 'w')
        f:write(hs.json.encode(module.clipboard_history, true))
        f:close()

        if params.archive then
            logger.i('Storing the archive.')
            f = io.open(params.archive, 'w')
            f:write(hs.json.encode(module.archive, true))
            f:close()
        end

    end

    hs.window.frontmostWindow():focus()  -- Always focus frontmost window before returning
end)

return module
