-- Original credits: https://github.com/VFS/.hammerspoon/blob/master/tools/clipboard.lua
-- luacheck: ignore module
local pasteboard_name = 'com.aldur.clipboard'
local logger = hs.logger.new('clipboard')

local module = {
    frequency = 1.0, -- Clipboar polling frequency.
    chooser_max_size = 1000, -- Number of elements to store in the chooser.
    element_max_length = 10000, -- Maximum length of elements to store.

    trim = true, -- Strip leading/trailing whitespace

    consider_ignore = true, -- Respect the `ignore` settings
    ignore = {
        ["de.petermaurer.TransientPasteboardType"] = true, -- Transient : Textpander, TextExpander, Butler
        ["com.typeit4me.clipping"] = true, -- Transient : TypeIt4Me
        ["Pasteboard generator type"] = true, -- Transient : Typinator
        ["com.agilebits.onepassword"] = true, -- Confidential : 1Password
        ["org.nspasteboard.TransientType"] = true, -- Universal, Transient
        ["org.nspasteboard.ConcealedType"] = true, -- Universal, Concealed
        ["org.nspasteboard.AutoGeneratedType"] = true -- Universal, Automatic
    },

    -- You don't need to edit anything below this line.
    last_focused_window = nil,
    clipboard_history = hs.settings.get(pasteboard_name) or {},
}

-- Internal method: Verify whether the pasteboard contents matches one of the identifiers that need to be ignored.
-- Code from https://github.com/asmagill/hammerspoon-config/blob/master/utils/_menus/newClipper.lua
local function shouldBeStored()
    if not module.consider_ignore then return true end
    for _, v in ipairs(hs.pasteboard.pasteboardTypes()) do
        if module.ignore[v] then return false end
    end
    for _, v in ipairs(hs.pasteboard.contentTypes()) do
        if module.ignore[v] then return false end
    end
    return true
end

-- Clears the last added to the history
local function clearLastItem()
    table.remove(module.clipboard_history, #module.clipboard_history)
    hs.settings.set(pasteboard_name, module.clipboard_history)
    module.chooser:choices(module.clipboard_history)
end

module.chooser = hs.chooser.new(function(row_info)
    if row_info then hs.pasteboard.setContents(row_info['text']) end
    if module.last_focused_window then module.last_focused_window:focus() end
end)

local image = hs.image.imageFromPath("icons/clipboard.png")

local function updateChoices()
    local choices = {}
    for _, v in pairs(module.clipboard_history) do
        table.insert(choices, {text = v.text, image = image})
    end
    module.chooser:choices(choices)
    module.chooser:rows(math.min(9, #choices)) -- Show at most 9 rows of elements in the chooser.
end

module.chooser:placeholderText("Query your clipboard history here...")
updateChoices()

-- Add `item`
local function toClipboard(item)
    -- Look for a copy of this element in the clipboard, and remove it if it's there.
    for i, v in pairs(module.clipboard_history) do
        if v.text == item then
            table.remove(module.clipboard_history, i)
            break
        end
    end

    -- Store the new element.
    table.insert(module.clipboard_history, 1, {text = item, date = os.date()})

    -- Make sure that the clipboard size respects the requirements.
    while (#module.clipboard_history >= module.chooser_max_size) do
        table.remove(module.clipboard_history)
    end

    updateChoices()

    -- Store the updated clipboard
    hs.settings.set(pasteboard_name, module.clipboard_history)
end

-- Clears the clipboard and history
local function clearAll()
    module.clipboard_history = {}
    assert(hs.settings.clear(pasteboard_name))
    hs.settings.set(pasteboard_name, module.clipboard_history)
    hs.pasteboard.clearContents()
    updateChoices()
end

local function storeCopy(current_clipboard)
    if not shouldBeStored() then return end

    if not current_clipboard then
        logger.v('Clipboard is empty. Clearing last item...')
        clearLastItem()
    elseif #current_clipboard > module.element_max_length then
        logger.v('Skipping entry too long...')
        return
    else
        if module.trim then
            -- Strip leading/trailing whitespace
            current_clipboard = current_clipboard:gsub("^%s*(.-)%s*$", "%1")
        end
        if not current_clipboard or current_clipboard == '' then return end

        toClipboard(current_clipboard)
    end
end

-- Set watched frequency.
hs.pasteboard.watcher.interval(module.frequency)
module.watcher = hs.pasteboard.watcher.new(storeCopy)

function module.toggle()
    local chooser = module.chooser
    if chooser:isVisible() then
        chooser:hide()
        if module.last_focused_window then
            module.last_focused_window:focus()
        end
    else
        module.last_focused_window = hs.window.focusedWindow()
        updateChoices()
        chooser:show()
    end
end

hs.urlevent.bind('clipboard', function(_, params)
    if params.clear_all then
        logger.i('Clearing the clipboard.')
        clearAll()
    else
        assert(params.clipboard)
        logger.i('Storing the clipboard.')

        local f = io.open(params.clipboard, 'w')
        assert(f ~= nil)
        f:write(hs.json.encode(module.clipboard_history, true))
        f:close()
    end

    hs.window.frontmostWindow():focus() -- Always focus frontmost window before returning
end)

return module
